# -*- coding: utf-8 -*-
"""innoDom_lesson_12.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1TZmJ4wNQ4CKsZgr4Cd2uwKyA7pieE5aR

# **Ещё про функции**

**Виды функций**

* Именованные функции
* Лямбды
* Генераторы \ итераторы
* Вложенные функции
* Декораторы

# **Лямбды**

`Lambda-функция` - это простая анонимная функция, которая нужна для
одноразового, в плане программы, использования и занимает одну
строчку.

Если функцию можно представить как лямбду и использовать
только в одном месте программы, то `lambda-функция` будет куда
эффективнее в плане читабельности и понимания.


В большинстве случаев такие функции используется как аргументы
встроенных, мощных функций таких, как `map` или `filter`, также их можно
использовать параметром в `sorted`.

**Синтаксис:**

Для создания `lambda-функции` используется ключевое слово `lambda`,
далее идут передаваемые аргументы, после двоеточия пишется
возвращаемое значение.
"""

# не самый лучший, но пример работы лямбды
def my_func(x, y):
  return x + y

sample_of_lambda = lambda x, y: x + y

print(sample_of_lambda(5, 10))

# более уместное использование лямбд

some_list = [5, 10, 15, 20, 25, 30, 35, 40]

print(map(lambda x: x ** .5, some_list))

# Создаем словарь, где значениями ключей являются lambda-выражения
user_input = input("Введите математическую операцию: ") # / * + - // % **
val_1 = int(input("Введите первое число: ")) # int('5') -> 5
val_2 = int(input("Введите второе число: ")) # float('8') -> 8.0

my_dict = {
    '+': lambda x, y: x + y,
    '-': lambda x, y: x - y,
    '/': lambda x, y: x / y,
    '//': lambda x, y: x // y,
    '%': lambda x, y: x % y,
    '*': lambda x, y: x * y,
    '**': lambda x, y: x ** y,
}
# add(5, 3)
# subtract(10, 4)
# multiply(2, 6)
if user_input in my_dict:
  print(my_dict.get(user_input)(val_1, val_2))

"""В реальных проектах использование `lambda-выражений` в качестве значений ключей словаря может быть полезным, если вам нужно хранить и вызывать компактные функции или операции в рамках словаря.

# **Применение лямбд**

Есть список словарей, где каждый словарь представляет один заказ со следующими полями: 'id', 'table_number' и 'bill'.
Написать функцию, которая принимает этот список заказов и возвращает новый список заказов, отсортированный по возрастанию суммы заказа.
"""

orders = [
    {'id': 1, 'table_number': 5, 'bill': 25.50},
    {'id': 2, 'table_number': 10, 'bill': 42.75},
    {'id': 3, 'table_number': 3, 'bill': 15.20},
    {'id': 4, 'table_number': 8, 'bill': 37.90},
    {'id': 5, 'table_number': 2, 'bill': 10.50},
    {'id': 6, 'table_number': 12, 'bill': 55.80},
    {'id': 7, 'table_number': 6, 'bill': 29.95},
    {'id': 8, 'table_number': 9, 'bill': 41.10},
    {'id': 9, 'table_number': 4, 'bill': 19.75},
    {'id': 10, 'table_number': 7, 'bill': 34.60},
    {'id': 11, 'table_number': 1, 'bill': 8.25},
    {'id': 12, 'table_number': 11, 'bill': 50.40},
    {'id': 13, 'table_number': 5, 'bill': 25.00},
    {'id': 14, 'table_number': 10, 'bill': 43.25},
    {'id': 15, 'table_number': 3, 'bill': 16.80},
    {'id': 16, 'table_number': 8, 'bill': 38.50},
    {'id': 17, 'table_number': 2, 'bill': 11.75},
    {'id': 18, 'table_number': 12, 'bill': 56.20},
    {'id': 19, 'table_number': 6, 'bill': 30.50},
    {'id': 20, 'table_number': 9, 'bill': 42.90},
    {'id': 21, 'table_number': 4, 'bill': 20.25},
    {'id': 22, 'table_number': 7, 'bill': 35.10},
    {'id': 23, 'table_number': 1, 'bill': 9.75},
    {'id': 24, 'table_number': 11, 'bill': 51.60},
    {'id': 25, 'table_number': 5, 'bill': 25.50},
    {'id': 26, 'table_number': 10, 'bill': 42.75},
    {'id': 27, 'table_number': 3, 'bill': 15.20},
    {'id': 28, 'table_number': 8, 'bill': 37.90},
    {'id': 29, 'table_number': 2, 'bill': 10.50},
    {'id': 30, 'table_number': 12, 'bill': 55.80}
]

def sort_orders_by_bill(data: list) -> list:
  return list(sorted(
      data,
      key=lambda x: x.get("bill")
  ))

import json

def wire_data() -> None:
  with open("sorted_orders.json", "w") as target_file:
    json.dump(sort_orders_by_bill(orders), target_file, indent=2)

wire_data()

"""Есть список словарей, где каждый словарь представляет одного клиента со следующими полями: 'id', 'name', 'age' и 'sex'.
Написать функцию, которая принимает этот список клиентов и возвращает количество женщин в списке.
"""

clients = [
    {'id': 1, 'name': 'Alice', 'age': 32, 'sex': 'Female'},
    {'id': 2, 'name': 'Bob', 'age': 45, 'sex': 'Male'},
    {'id': 3, 'name': 'Charlie', 'age': 28, 'sex': 'Male'},
    {'id': 4, 'name': 'David', 'age': 54, 'sex': 'Male'},
    {'id': 5, 'name': 'Eva', 'age': 39, 'sex': 'Female'},
    {'id': 6, 'name': 'Frank', 'age': 42, 'sex': 'Male'},
    {'id': 7, 'name': 'Grace', 'age': 61, 'sex': 'Female'},
    {'id': 8, 'name': 'Henry', 'age': 50, 'sex': 'Male'},
    {'id': 9, 'name': 'Isabella', 'age': 26, 'sex': 'Female'},
    {'id': 10, 'name': 'Jack', 'age': 33, 'sex': 'Male'},
    {'id': 11, 'name': 'Kate', 'age': 49, 'sex': 'Female'},
    {'id': 12, 'name': 'Liam', 'age': 23, 'sex': 'Male'},
    {'id': 13, 'name': 'Mia', 'age': 37, 'sex': 'Female'},
    {'id': 14, 'name': 'Noah', 'age': 58, 'sex': 'Male'},
    {'id': 15, 'name': 'Olivia', 'age': 41, 'sex': 'Female'},
    {'id': 16, 'name': 'Peter', 'age': 31, 'sex': 'Male'},
    {'id': 17, 'name': 'Quinn', 'age': 56, 'sex': 'Female'},
    {'id': 18, 'name': 'Ryan', 'age': 35, 'sex': 'Male'},
    {'id': 19, 'name': 'Sophia', 'age': 47, 'sex': 'Female'},
    {'id': 20, 'name': 'Thomas', 'age': 29, 'sex': 'Male'},
    {'id': 21, 'name': 'Uma', 'age': 60, 'sex': 'Female'},
    {'id': 22, 'name': 'Victoria', 'age': 44, 'sex': 'Female'},
    {'id': 23, 'name': 'William', 'age': 52, 'sex': 'Male'},
    {'id': 24, 'name': 'Xavier', 'age': 36, 'sex': 'Male'},
    {'id': 25, 'name': 'Yara', 'age': 30, 'sex': 'Female'},
    {'id': 26, 'name': 'Zoe', 'age': 43, 'sex': 'Female'},
    {'id': 27, 'name': 'Alex', 'age': 27, 'sex': 'Male'},
    {'id': 28, 'name': 'Benjamin', 'age': 48, 'sex': 'Male'},
    {'id': 29, 'name': 'Chloe', 'age': 38, 'sex': 'Female'},
    {'id': 30, 'name': 'Daniel', 'age': 55, 'sex': 'Male'}
]

def calculate_woman(clients: list) -> int:
  y = filter(
      lambda x: x.get("sex") == "Female",
      clients
      )
  return len(list(y))

calculate_woman(clients)

"""Работаем над системой анализа текста.
Написать функцию, которая принимает текстовую строку и список стоп-слов (слов, которые не несут смысловой нагрузки \ оскорбления), и возвращает новую строку, в которой удалены все стоп-слова из исходного текста
"""

from string import punctuation # спец библиотека для работы с символами пунктуации

some_string = "One bastard started the War, and world destabilisation. Please, stop conflict"
stop_words = ["war", "destabilisation", "bastard", "stop", "conflict"]

"""# **Генераторы \ итераторы**

`Итеративный объект` – это объект, по которому можно совершить
итерацию.

`Итераторы` – это функции либо конструкции языка, которые позволяют
проходиться по итеративным объектам.

Вы уже знакомы со способом прохода через цикл. Однако, если в
итеративном объекте хранится много значений, тогда на помощь приходит
функция `iter()` и `next()`, которые позволяют не хранить целый объект в
памяти, а извлекают его и хранят только текущий элемент.


Когда элементы в итераторе заканчиваются, вызывается исключение `StopIteration`.

Как это выглядит:
"""

my_list = {"one", "two", "three", "four", "five", "six", "seven", "eight", "nine"}
my_iter = iter(my_list)
print(type(my_iter))
print(next(my_iter))
print(next(my_iter))
print(next(my_iter))
print(next(my_iter))
print(next(my_iter))
print(next(my_iter))
print(next(my_iter))
print(next(my_iter))
print(next(my_iter))
# print(next(my_iter))

# так же можем юзать set() tuple(), dict()
my_dict = {"a": 1, "b": 2}
my_new_iter = iter(my_dict.values()) # для словарей можем создавать итераторы по ключам, значениям, элементам
print(type(my_new_iter))
print(next(my_new_iter))
print(next(my_new_iter))

"""Вы так же можете написать свою реализацию итератора (иногда просят реализовать на собеседовании)

![image.png](data:image/png;base64,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)

Итераторы полезны, когда мы хотим выполнять итерацию через большие или бесконечные коллекции, такие как файлы, базы данных или потоки данных.

`Генератор` – это функция, которая позволяет делать вам свои итераторы.
"""

def multiple_value_generator(value):
  while value < 50:
    yield value
    value *= 2


custom_generator = multiple_value_generator(2)

print(next(custom_generator))
print(next(custom_generator))
print(next(custom_generator))
print(next(custom_generator))
print(next(custom_generator))
print(next(custom_generator))

"""Генераторы очень эффективны, когда нам нужно производить значения по мере необходимости, а не сразу все сразу. Они также помогают сэкономить память, так как не требуют хранения всех значений в памяти одновременно.

Генераторы могут быть бесконечными, и их выполнение может продолжаться до бесконечности. Мы можем ограничить количество итераций с помощью функции `range()` или условного оператора.

Генераторы также могут быть использованы вместе с различными функциями, такими как `map()`, `filter()` и `reduce()`, чтобы создавать компактный и выразительный код.

Вот некоторые способы применения генераторов и итераторов:

* Постепенная обработка больших объемов данных, таких как чтение больших файлов или баз данных по мере необходимости.
* Ленивая загрузка данных из внешних источников.
* Генерация итерируемых последовательностей с определенными правилами или условиями.
* Фильтрация или преобразование элементов в коллекции.
* Рекурсивные итерации без использования рекурсивных вызовов функций, чтобы избежать переполнения стека.

Задача: Фильтрация данных из базы данных.
Реализуйте итератор, который позволяет получать только те записи из базы данных, где возраст пользователя больше 18. ID этих пользователей записать в список users_white_list для передачи фронту
"""

database_data = [
    {"id": 1, "username": "user123", "email": "user123@example.com", "age": 25},
    {"id": 2, "username": "john_doe", "email": "johndoe@example.com", "age": 15},
    {"id": 3, "username": "emma_s", "email": "emma_s@example.com", "age": 42},
    {"id": 4, "username": "alex21", "email": "alex21@example.com", "age": 21},
    {"id": 5, "username": "lisa_smith", "email": "lisa.smith@example.com", "age": 30},
    {"id": 6, "username": "max_power", "email": "max_power@example.com", "age": 15},
    {"id": 7, "username": "sara_m", "email": "saram@example.com", "age": 28},
    {"id": 8, "username": "brian88", "email": "brian88@example.com", "age": 33},
    {"id": 9, "username": "julia_c", "email": "juliac@example.com", "age": 17},
    {"id": 10, "username": "sam99", "email": "sam99@example.com", "age": 14},
    {"id": 11, "username": "megan_ross", "email": "megan.ross@example.com", "age": 23},
    {"id": 12, "username": "mark_johnson", "email": "markjohnson@example.com", "age": 17},
    {"id": 13, "username": "amy_w", "email": "amy_w@example.com", "age": 18},
    {"id": 14, "username": "chris25", "email": "chris25@example.com", "age": 25},
    {"id": 15, "username": "natalie_g", "email": "natalieg@example.com", "age": 14},
    {"id": 16, "username": "michael_b", "email": "michaelb@example.com", "age": 19},
    {"id": 17, "username": "lucas34", "email": "lucas34@example.com", "age": 27},
    {"id": 18, "username": "olivia_smith", "email": "olivia.smith@example.com", "age": 14},
    {"id": 19, "username": "david_p", "email": "davidp@example.com", "age": 21},
    {"id": 20, "username": "sophie_w", "email": "sophiew@example.com", "age": 17},
    {"id": 21, "username": "ryan_miller", "email": "ryan.miller@example.com", "age": 35},
    {"id": 22, "username": "lily_g", "email": "lilyg@example.com", "age": 14},
    {"id": 23, "username": "patrick_s", "email": "patricks@example.com", "age": 37},
    {"id": 24, "username": "grace41", "email": "grace41@example.com", "age": 41},
    {"id": 25, "username": "daniel_h", "email": "danielh@example.com", "age": 15},
    {"id": 26, "username": "victoria99", "email": "victoria99@example.com", "age": 24},
    {"id": 27, "username": "jacob_t", "email": "jacobt@example.com", "age": 14},
    {"id": 28, "username": "sophia_c", "email": "sophiac@example.com", "age": 16},
    {"id": 29, "username": "andrew_j", "email": "andrewj@example.com", "age": 23},
    {"id": 30, "username": "emily_rose", "email": "emily.rose@example.com", "age": 17},
]

def filter_data_by_age(data: list, age: int) -> list:
  for record in data:
    if record.get("age") > age:
      yield record


def write_filtered_data_to_white_list(records: list) -> list:
  white_list_id: list = []

  for user in records:
    white_list_id.append(user.get("id"))

  return white_list_id

data = write_filtered_data_to_white_list(filter_data_by_age(
    database_data,
    18
))

data

"""Задача: Генерация уникальных идентификаторов.
Напишите генератор, который создает уникальные идентификаторы для объектов, добавляемых в систему. Уникальный идентификатор может быть строкой или числом и должен гарантировать уникальность для каждого нового объекта.
"""

from uuid import uuid4

def geterate_unique_ids(limit: int):
  while limit != 0:
    yield str(uuid4())
    limit -= 1

id_generator = geterate_unique_ids(4)

names = ["Viktor", "Olya", "Andrey", "John"]
unique_ids = {}

for name in names:
  unique_id = next(id_generator)
  unique_ids[name] = unique_id
  print(f"Записал уникальный ID '{unique_id}' для {name}")

"""**Итеративные и генеративные выражения:**

`Итеративные и генеративные выражения` – это списковые включения для
упрощения читабельности и сокращения кода, такие включения можно
делать для списков, словарей, множеств, генераторов.


Шаблон спискового включения:

`[возвращаемое_значение цикл условие_не_обязательно]`
"""

# 
comprehension_ = [i for i in range(1, 11)]
dict_ = {x: (lambda num: num ** 2)(x) for x in range(1, 8)}

print(comprehension_)
print(type(comprehension_))
print(dict_)
print(type(dict_))

"""`Генеративное выражение` – это списковое включение, которое создаёт
новую последовательность, создание происходит в виде кортежа, т.е в
круглых скобках.
"""

my_gen = (i * 3 for i in range(1, 11))

print(type(my_gen))
# for i in my_gen:
#   print(i, end=" ")

print(next(my_gen))
print(next(my_gen))

"""`Итеративное выражение` – это списковое включение, которое работает уже с существующим итерируемым объектом."""

my_list = [2, 4, 6, 8, 10, 12, 14, 16, 18, 20]

my_iterator = [val * 2 for val in my_list]

print(type(my_iterator))
my_iterator

"""Итеративные выражения используются для создания итерируемых объектов с помощью синтаксиса списка (list comprehension) или генератора множества (set comprehension). Они позволяют нам создавать последовательности значений на основе других последовательностей или итерируемых объектов."""

squares = [x**2 for x in range(1, 5)]

print(squares)
print(type(squares))

even_numbers = {x for x in range(1, 10) if x % 2 == 0}

print(even_numbers)
print(type(even_numbers))

"""Итеративные выражения создают новую последовательность значений и могут быть преобразованы в конкретные коллекции данных, такие как списки, множества или кортежи.

Генеративные выражения используются для создания генераторов - итерируемых объектов, которые генерируют значения по мере необходимости, без хранения всех значений в памяти.

Генераторы используют ключевое слово `yield`, чтобы вернуть значения и сохранить состояние выполнения функции.

Генеративные выражения возвращают генераторы, которые могут быть использованы в циклах for или получать значения с помощью функции `next()`. Они особенно полезны, когда требуется работать с большими объемами данных или генерировать значения по требованию без необходимости хранения всех значений в памяти.
"""

numbers = (x for x in range(1, 6))
for num in numbers:
    print(num ** 4)

squares = (x**4 for x in range(1, 6))
for square in squares:
    print(square)

even_numbers = (x for x in range(1, 11) if x % 2 == 0)
for num in even_numbers:
    print(num)

colors = ['red', 'green', 'blue']
sizes = ['S', 'M', 'L']
combinations = ((color, size) for color in colors for size in sizes)

for combination in combinations:
    print(combination)

"""Синтаксис итеративных и генеративных выражений в Python очень похож, но есть некоторые различия:

1. Синтаксис:

`Итеративное выражение:` Используется в квадратных скобках [] или фигурных скобках {} для создания списка или множества.

`Генеративное выражение:` Используется в круглых скобках () для создания генератора.

2. Использование:

`Итеративное выражение:` Создает новую коллекцию данных (список, множество и т. д.), которая может быть использована непосредственно.

`Генеративное выражение:` Создает генератор, который генерирует значения по требованию и сохраняет состояние выполнения функции.

3. Хранение значений:

`Итеративное выражение:` Создает и хранит все значения в памяти, чтобы вернуть коллекцию данных целиком.

`Генеративное выражение:` Генерирует значения по мере необходимости, сохраняя минимальное состояние в памяти.


4. Использование в циклах:

`Итеративное выражение:` Можно использовать напрямую в цикле for для итерации по всем элементам коллекции.

`Генеративное выражение:` Необходимо использовать функцию next() или включить генератор в цикл for для получения значений.


5. Возможности:

`Итеративное выражение:` Позволяет преобразовывать и фильтровать значения, а также создавать новую коллекцию данных.

`Генеративное выражение:` Позволяет генерировать значения на лету и эффективно работать с большими объемами данных.

# **Вложенные функции**

**Вложенные функции** - это функции, которые находятся друг в друге. Такие функции могут быть использованы только внутри родительской. Благодаря этому можно добиться взаимодействия между функциями вместе с их общими аргументами.
"""

def printer(value: int) -> None:

  def print_hello() -> None:
    print("Hello, ")

  def print_world() -> None:
    print("World!")

  if value == 1:
    print_hello()

  else:
    print_world()


printer(2)

"""# **Декораторы**

**Декораторы** - это функции, позволяющие обернуть другие функции, для расширения функциональности функции, которую изменяет декоратор.

Иными словами, декоратор - это функция, которая изменяет либо расширяет функционал другой функции

Декораторы работают на основе вложенных функций: принимают в себя объект функции, которую в последующем можно вызвать внутри
декоратора. Ведь функции, как и переменные, хранят только код, а не значения.
"""

# def sandwich(function):
#   def wrapper():
#     print("\\\\\\\Булка//////")
#     print("%$%%Салат$%%$")
#     function()
#     print("~~~~Кепчук~~~~")
#     print("\\\\\\\Булка//////")
#   return wrapper

"""Декораторы применяются на функции, которые требуется декорировать.

Такой декоратор, что мы указали можно применять на любую функцию, подходящую по смыслу(создавать свой бутер). При вызове такой функции, декоратор будет отрабатывать вместе с ней.

**Вызов декораторов:**

Вызывать наши декораторы можно двумя способами:

1. Название декоратора через символ собачки над функцией, которую мы хотим декорировать 
```
@my_decorator
my_function():
...
```

2. Прописывать переменную и закидывать в неё декоратор, в скобках декоратору передавать функцию, которую хотим обернуть
При вызове переменной-декоратора ставить скобки, тем самым вызывая декоратор

```
my_decorator_var = my_decorator(my_function)
my_decorator_var()
```
"""

def sandwich(function):
  def wrapper():
    print("Булка")
    function()
    print("Салат")
    print("Кепчук")
    print("Булка")
    
  return wrapper

@sandwich
def beef_sandwich() -> None:
  print("###Говядинка###")

@sandwich
def pork_sandwich():
  print("Свинина")

# sandwich
# def beef_sandwich() -> None:
#   print("###Говядинка###")

beef_sandwich()
print("-" * 45)
pork_sandwich()

"""Так же декораторы могут работать с функциями с аргументами:"""

def log_decorator(func):
    def wrapper(*args, **kwargs):
        print(f"Вызов функции '{func.__name__}' с аргументами {args} {kwargs}")
        result = func(*args, **kwargs)
        print(f"Результат выполнения функции: {result}")
        return result
    return wrapper

@log_decorator
def sum_two_values(a, b):
    return a + b

@log_decorator
def multiply(a, b):
  return a * b

result = sum_two_values(35, 170)
multiply(5, b=15)

result

import time

def measure_time(func):
    def wrapper(*args, **kwargs):
        start_time = time.time()
        result = func(*args, **kwargs)
        end_time = time.time()
        execution_time = end_time - start_time
        print(f"Время выполнения функции '{func.__name__}': {execution_time} сек.")
        return result
    return wrapper

@measure_time
def long_running_task():
    # Долгий процесс
    time.sleep(2)
    print("Завершено")

long_running_task()

"""Так же декораторы могут содержать в себе аргументы

Декораторы с аргументами реализуются с помощью двух уровней функций: внешней функции, которая принимает аргументы декоратора, и внутренней функции-декоратора, которая принимает функцию для декорирования.
"""

def decorator_with_arguments(arg1, arg2):
    def decorator(func):
        def wrapper(*args, **kwargs):
            print(f"Декоратор получил аргументы: {arg1}, {arg2}")
            result = func(*args, **kwargs)
            return result
        return wrapper
    return decorator

@decorator_with_arguments("Аргумент 1", "Аргумент 2")
def hello():
    print("Привет!")

hello()

# Функция wraps предоставляет простой способ сохранить метаданные
# оригинальной функции при создании обертки внутри декоратора.
# Это особенно полезно, когда вы создаете декораторы, которые
# изменяют поведение функции, но вы хотите сохранить ее имя,
# документацию и другие атрибуты.

# При использовании декоратора без wraps, метаданные оригинальной
# функции могут быть потеряны, и вместо этого будут отображаться
# метаданные обертки. Чтобы избежать этой проблемы, вы можете
# использовать wraps внутри вашего декоратора.

from functools import wraps
from datetime import datetime, timedelta

def cache_decorator(ttl):
    def decorator(func):
        cache = {}

        @wraps(func)
        def wrapper(*args, **kwargs):
            key = (args, frozenset(kwargs.items()))

            if key in cache and datetime.now() - cache[key][0] < timedelta(seconds=ttl):
                print("Берем результат из кэша")
                return cache[key][1]
            
            result = func(*args, **kwargs)
            cache[key] = (datetime.now(), result)
            return result
        return wrapper
    return decorator

@cache_decorator(ttl=)
def expensive_operation(n):
    print("Выполняем дорогостоящую операцию")
    return n ** 2

print(expensive_operation(3))
print(expensive_operation(3))

print(expensive_operation(3))

print(expensive_operation(3))

print(expensive_operation(4))

print(expensive_operation(4))

from functools import wraps
from datetime import datetime, timedelta

def cache_decorator(ttl): # Определяем внешнюю функцию cache_decorator, которая принимает аргумент ttl (время жизни кэша):
    def decorator(func): # определяем внутреннюю функцию-декоратор decorator, которая принимает функцию func для декорирования
        cache = {} # Создаем словарь cache, который будет служить для хранения кэшированных результатов

        @wraps(func) # Определяем функцию-обертку wrapper, которая будет вызываться вместо оригинальной функции func
        def wrapper(*args, **kwargs): # Создаем уникальный ключ key на основе переданных аргументов
            key = (args, frozenset(kwargs.items()))


            # Проверяем, есть ли ключ в кэше и не истекло ли время жизни ttl
            # для данного ключа.
            if key in cache and datetime.now() - cache[key][0] < timedelta(seconds=ttl):
                print("Берем результат из кэша")
                # Если это так, то возвращаем сохраненное значение из кэша
                return cache[key][1]
            
            # Если ключ отсутствует в кэше или время жизни ttl истекло,
            # то вызываем оригинальную функцию func и сохраняем
            # результат в кэше с текущим временем:
            result = func(*args, **kwargs)
            cache[key] = (datetime.now(), result)
            return result
        # Возвращаем функцию-обертку wrapper в качестве результата
        # внутренней функции decorator
        return wrapper
    # которая в свою очередь возвращается внешней функцией cache_decorator.
    return decorator

@cache_decorator(ttl=3)
def expensive_operation(n):
    print("Выполняем дорогостоящую операцию")
    return n ** 2

print(expensive_operation(3))  # Выполняем дорогостоящую операцию, результат: 6
print(expensive_operation(3))
print(expensive_operation(4))