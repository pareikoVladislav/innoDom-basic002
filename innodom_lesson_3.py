# -*- coding: utf-8 -*-
"""innoDom_lesson_3.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1drnTAZAeDjwiFZ6p2Uhg7I7fi4PSkL7I

# **Строки. Работа со строками. Литералы и форматирование.**

Давайте немного повторим то, что мы с вами знаем о строковом типе данных.
**Строки в Python** - упорядоченные последовательности символов, используемые для хранения и представления текстовой информации, поэтому с помощью строк можно работать со всем, что может быть представлено в текстовой форме.

Наши с вами строки - неизменяемый тип данных, так как это упорядоченные последовательности - каждый символ в строке у нас проиндексирован ( индексация начинается с нуля! ) и идёт по порядку.

Строки мы можем создать следующими путями:
"""

new_string = "my string"
new_string_2 = 'one more string'
new_string_3 = str(12334567890)
new_string_4 = """ super


string """

print(new_string, new_string_2, new_string_3, new_string_4, sep="\n")

print(type(new_string), type(new_string_2), type(new_string_3), type(new_string_4), sep="\n")

one_more_new_string = str([1, 2, 3, 'qweqwe', [1, 2, 3]])
one_more_new_string_2 = str({"a": 1, "b": 2, "c": 3})

print(one_more_new_string)
print(type(one_more_new_string))

print(one_more_new_string_2)
print(type(one_more_new_string_2))

dict(one_more_new_string_2) # работать не будет!
json_obj = json.loads(str(one_more_new_string_2)) # так же не будет работать

import json

json_obj = json.loads('{"a": 1, "b": 2, "c": 3}')

print(json_obj)

print(type(json_obj))

"""Так же не забываем, что мы можем получать отдельные символы из наших строк, делать по ним срезы, складывать строки, дублировать и ещё много чего. Давайте разбираться:

У так как наши строки являются последовательностью, они имеют индексацию ( она начинается с нуля ) и мы можем обращаться к этим индексам:
"""

new_string = "1q2w3e4r5t6y7u"

print(new_string[1]) # получить конкретный элемент из нашей последовательности

print(new_string[1:]) # получить срез символов из последовательности

print(new_string[2:6])

"""При работа со срезом есть ещё и третий аргумент ( так сказать ) - шаг.
**Шаг** - количество символов, через которые мы будем проходить в нашем срезе:
"""

print(new_string[::2])

"""За счёт шага в срезе мы можем выбирать конкретные элементы в нашей строке, не прибегая при этом к циклам ( хотя лучше циклы ). Так же, если мы будем указывать шаг, который превышает по длине нашу строку - мы просто будем получать первый элемент:"""

print(new_string[::14])

"""Так же благодаря шагам мы можем перевернуть нашу строку. Это может пригодиться, если вам нужно проверить строку на палиндром:"""

print(new_string[::-1])

"""# **Литералы строк.**

Строки в апострофах и в кавычках - одно и то же. Причина наличия двух вариантов в том, чтобы позволить вставлять в литералы строк символы кавычек или апострофов, не используя экранирование:
"""

error_message = "The password field for 'testuser@gmail.com' email is empty"
warn_message = 'No updates for the "Apple INC" profile'

"""**Экранированные строк - служебные символы.**

* `\n` - Перевод строки.
* `\a` - Гудок встроенного в систему динамика.
* `\b` - Backspace, он же возврат, он же "пробел назад" – удаляет один символ перед курсором.Если `\b` находится в конце строки, то удаления не происходит.
* `\f` - Разрыв страницы.Указывает в каком месте заканчивается одна страница и начинается другая.

Раньше он использовался для управления подачей бумаги в принтерах. Когда принтер встречал этот символ, это означало что ему надо было извлеч страницу и загрузить на печать следующий лист бумаги. Сейчас, он может встретиться (и то не факт, что встретится) разве что в исходных кодах некоторых языков программирования, в которых принято соглашение разбивать код на разделы с помощью этого символа. Например, интерпретатор Python способен учитывать \f при расчете отступов при анализе кода.

* `\r` - Возврат каретки. Возврат курсора в начало строки.
* `\t` - Горизонтальная табуляция. Горизонтальный отступ слева от начала строки.
* `\v` - Вертикальная табуляция. Вертикальный отступ сверху
* `\N{id}` - Идентификатор ID базы данных Юникода:
"""

print('\N{Winking Face}')

print("Hello\nWorld\n!\n!\n!")

print("Hello World!!", sep="\b")
print("Hello World!!", "Hello, World!!!", sep="\b")

print("Hel\rlo World!!!!")

print("Hello World!", "Hello World!!", "Hello World!!!", sep="\N{Winking Face}")

"""Ещё есть следующий спец символ:
* \newline - где newline продолжение строки
"""

sample_of_string = "This is a \
very \
veeeryyy \
veeeeeeeeerrrryyyyyy \
huge string!!!"

print(sample_of_string)

"""Относительно последнего спец символа думаю всё достаточно просто. Но выглядит не особо красиво, думаю согласитесь. Для решения такого запроса в Python существует так же создание гиперстрок:"""

hyper_string = """
my hyper string and message!
"""

"""Такие строки могут облегчить вам жизнь за счёт простоты в использовании и чтении. Она ничем не будет отличаться от обычной строки, разница лишь в том, что благодаря такому определению строк мы можем помещать большие текстовые данные, не прибегая при этом к `\` разделителям при необходимости.

Встречаются такие строки в технической документации к классам, функциям, файлам, к написанию SLQ запросов непосредственно в Python, но до этого ещё дойдём.
"""

print(hyper_string)
print(type(hyper_string))

"""# **Форматирование строк**

Думаю мы с вами разобрались уже со строками, тем, как же их нам определять, какими они могут быть, что у них есть. Но что делать, если мы хотим, чтобы часть строки у нас была более динамичной, чтобы значения в нем могли меняться исходя из каких-то событий?

Для такой работы существует как раз наше форматирование строки.

**Форматирование строк** - это процесс создания строки, содержащей заранее определенные заменители (placeholders), которые будут заменены на значения переменных или выражений во время выполнения программы. Форматирование строк является одним из способов создания строк в Python и используется для удобства вывода информации в консоли или в файл.

Существуют различные способы форматирования строк. Давайте пройдёмся от давних методов, которые можно встретить до сих пор, хоть и редко, до новых, которыми пользуются по сей день.

1. **Форматирование при помощи знака `%`**
* Оператор `%` используется для замены заранее определенных заменителей на значения переменных или выражений:
"""

name = 'world'
age = 42
message = 'Hello, %s! You are %d years old.' % (name, age)
print(message)

"""В этом примере мы заменяем знак `%s` на строку 'world', а знак `%d` на число 42

Как нам не запутаться во всех этих знаках?

Вот небольшой список возможных значений, которые мы можем подставлять к нашему проценту:

* `%d`, `%i`, `%u` - Десятичное число.
* `%o` - Число в восьмеричной системе счисления.
* `%x` - Число в шестнадцатеричной системе счисления (буквы в нижнем регистре).
* `%X` - Число в шестнадцатеричной системе счисления (буквы в верхнем регистре).
* `%e` - Число с плавающей точкой с экспонентой (экспонента в нижнем регистре).
* `%E` - Число с плавающей точкой с экспонентой (экспонента в верхнем регистре).
* `%f`, `%F` - Число с плавающей точкой (обычный формат).
* `%g` - Число с плавающей точкой. с экспонентой (экспонента в нижнем регистре), если она меньше, чем -4 или точности, иначе обычный формат.
* `%G` - Число с плавающей точкой. с экспонентой (экспонента в верхнем регистре), если она меньше, чем -4 или точности, иначе обычный формат.
* `%c` - Символ (строка из одного символа или число - код символа).
* `%r` - Строка (литерал python).
* `%s` - Строка (как обычно воспринимается пользователем).
* `%%` - Знак `%`.

Флаги преобразования:
* `#` - Значение будет использовать альтернативную форму.
* `0` - Свободное место будет заполнено нулями.
* `-` - Свободное место будет заполнено пробелами справа.
* `""` - Свободное место будет заполнено пробелами справа.
* `+` - Свободное место будет заполнено пробелами слева.

Этот способ форматирования достаточно стар и мало где используется, хоть и используется. Если где-то встретите символы процента в строке - не пугайтесь и не думайте, что же это такое. Вы будете уже с этим знакомы.

2. **Форматирование строк при помощи метода .format()**

Этот метод является более новым и используется до сих пор. Достаточно практичный, хороший и удобный метод для работы с динамичными значениями в строках.

Часто используется при работе с какими-нибудь готовыми текстовыми шаблонами, в которые необходимо подставлять нужные значения только в определённые места ( шаблонные письма для рассылок и т.д )

Давайте разбираться на практике
"""

dynamic_value = input()

print("Hello, {}".format(dynamic_value))

"""Мы так же можем передавать и несколько аргументов подряд, если необходимо:"""

dynamic_name = input()
dynamic_age = int(input())

print("Hi! My name is {}, I'm {} y.o.".format(dynamic_name, dynamic_age))

"""Каков принцип работы нашего метода, если у нас несколько аргументов на вход?
Если у нас фигурных скобок в шаблоновой строке больше, чем аргументов и мы не задавали никаких последовательностей - у нас будет ошибка, так как наш Python будет пытаться найти аргументы, которых нет.

При этом же, если у нас самих аргументов больше, чем наших фигурных скобок, при этом мы ничего не указывали в последовательности подставления, то Python будет брать наши аргументы по порядку для подставления, а всё, что останется вне наших фигурных скобок - просто проигнорируется.

Давайте разбираться:
"""

a = "Some string {} {} {} {}"

b = "One more string {} {}"

print(a.format("arg_1", "arg_2", "arg_3", "arg_4"))

print(a.format("arg_1", "arg_2", "arg_3")) # Будет ошибка, так как нам не достаёт одного аргумента для нашего шаблона

print(b.format("arg_1", "arg_2", "arg_3")) # Ошибки не будет, наш третий аргумент пропустится

"""Так же мы можем сами определять очерёдность наших аргументов:"""

a = "{1} {0} {2}"

print(a.format("arg_1", "arg_2", "arg_3"))

"""Если мы сами определяем очерёдность наших аргументов, то в таком случае в целом мы можем ( в теории ) указать аргументов меньше, чем их должно быть в шаблоне:"""

b = "{0}-{1}-{0}"

print(b.format("abra", "kad"))

"""Если вдруг кому-то неудобно идти по индексам при определении последовательности наших аргументов - мы можем делать это через имена:"""

a = "Hi! My name is {name}, I'm {age} y.o."

person = {
    "name": "Adam",
    "age": 32
}

print(a.format(name="Viktor", age=25))

print(a.format(**person))

"""3. **Форматирование строки через символ `f`**

Последний и актуальный, достаточно частый в использовании способ сделать нашу строку более гибкой - создание f-строки. Каков синтаксис:
"""

page_site = "VK"
status_code = 500
message = f"Can't loading '{page_site}' page. Unsecure connection."

error_message = f"Error. Status code: {status_code}, Error message: {message}"

print(error_message)

"""# **Методы строк**

У строк, как и у всех типов данных из разряда коллекций, есть свои методы. Давайте пройдёмся по самым распространённым из них.

**Метод len()**

Он относится не конкретно к строкам, а скорее ко всем коллекциям. Этот метода просто возвращает нам длинну того, что мы поместим в него.
"""

print(len("qwerty")) # У нешего qwerty шесть символов, поэтому и длинна будет 6

"""**Методы lower() и upper()**


Очень похожи друг на друга методы, которые предназначены для конвертации символов строки в верхний, или нижний регистр.

Могут пригодиться, когда вы сравниваете строковые данные и не уверены, что в них используется только нижний, или верхний регистр. Этими методами вы можете привести всё к одному единому формату.
"""

lower_string = "some string value in lower case"

print(lower_string.upper())

upper_string = "ANSJDKANSD AJSNDKAJSDUIQWE QWELQWE"

print(upper_string.lower())

print("njJmLn$86H_@7UJ$@9Oo0-oU6_55t@$_kKmU-@vuv@-79N9@0-76rf-56".upper())

"""Самые распространённые места применения таких методов на моей практике - моменты, когда вам нужно проверить имя пользователя. Некоторые могут вводить свои имена и фамилии с маленькой буквы, а некоторые с большой.

Ещё один интересный и полезный моментами метод - это **метод strip()**

Предназначен для удаления пробельных символов в начале и в конце строки. Так же зачастую используется при проверках имени пользователя.
"""

user_name = "Mark zukerberg "

print(len(user_name))

updated_name = user_name.lower().strip()

print(updated_name)

print(len(updated_name))

"""**Метод split()**

Один из наиболее используемых в программировании. Этот метод может разделить строку на список подстрок на основе заданного разделителя (по умолчанию - пробел).
"""

my_string = "Hello, World! We're using Python!"

converted_string = my_string.split()

print(converted_string)

converted_string_2 = my_string.split(",")

print(converted_string_2)

converted_string_3 = my_string.split("e")

print(converted_string_3)

"""Следующий метод делает ровно обратное.


**join()** - принимает в себя список со строками и конвертирует их в одну строку с использованием заданного разделителя.
"""

list_of_strings = ["We're", "learn", "Python", "language."]

print(' '.join(list_of_strings))

list_of_values = (1, 2, 3, 4, 5, 6, 7, 8, 9, 0)

sql_query = f"""
  SELECT *
  FROM table_name
  WHERE table_name.value
  IN({','.join([str(value) for value in list_of_values])})
"""

print(sql_query)

employes_list = ["Mark", "Isabel", "Daniel", "Irina", "Margaret"]

message_template = f"""
  Dear {', '.join([str(value) for value in employes_list])}
  You're fired.
"""

print(message_template)

"""**Метод replace()**

Этот метод принимает в себя два аргумента: подстроку, которую вы хотите заменить и подстроку, НА которую вы хотите заменить. Чтобы не было путаницы в теории, давайте разбираться на практике:
"""

string_1 = "Hi! I'm using Java!"

print(string_1.replace("Java!", "Python!"))

print(string_1)

"""Ещё некоторые методы, которые могут встречаться, или понабодиться:

* **isalnum()** - проверяет, состоит ли строка только из букв и цифр
* **isalpha()** - проверяет, все ли символы в строке - часть алфавита. Возвращает bool значение.
* **isdigit()** - проверяет, состоит ли строка только из цифр. Возвращает bool значение.
* **title()** - преобразовывает строку таким образом, чтобы первая буква каждого слова была заглавной. 
* **capitalize()** - преобразовывает строку таким образом, что первая подстрока будет начинаться с заглавной буквы.
* **isascii()** - содержит ли строка только символы ASCII (American Standard Code for Information Interchange). ASCII — это стандартный набор символов, который включает в себя буквы английского алфавита (прописные и строчные), цифры, знаки пунктуации и некоторые специальные символы.
* **encode()** - используется для преобразования строки в последовательность байтов, используя определенное кодирование (encoding). Кодирование определяет, как символы будут представлены в виде байтовых значений.

Метод **encode()** полезен, когда требуется преобразовать строку в байтовую последовательность для передачи или сохранения данных, особенно при работе с сетевыми протоколами или файлами. Необходимо убедиться, что используемое кодирование соответствует ожиданиям и типу данных, с которыми идёт работа.

# **Немного задач на закрепление:**

**Задача: Проверка наличия подстроки**

* Пользователь вводит строку и подстроку.
* Вывести сообщение, содержит ли введенная строка данную подстроку.

Задача: Замена символов

* Пользователь вводит строку.
* Заменить все вхождения символа "a" в строке на символ "b".
* Вывести измененную строку.

Задача: Разделение строки

* Пользователь вводит строку, содержащую имена, разделенные запятыми.
* Разделить строку на список имен.
* Вывести список имен.

Задача: Форматирование имени

* Пользователь вводит свое имя.
* Преобразовать первую букву имени в верхний регистр и остальные буквы в нижний регистр.
* Вывести отформатированное имя.

Задача: Подсчет символов

* Пользователь вводит строку.
* Подсчитать количество символов в строке (без учета пробелов).
* Вывести количество символов.

Задача: Объединение строк

* Пользователь вводит две строки.
* Объедините строки в одну, добавив пробел между ними.
* Вывести объединенную строку.

Задача: Проверка на число

* Пользователь вводит строку.
* Проверить, является ли введенное значение числом.
* Вывести сообщение о результате проверки.

Задача: Удаление пробелов

* Пользователя вводит строку, возможно, содержащую пробелы в начале и конце.
* Удалить все пробелы в начале и конце строки.
* Вывести очищенную строку.

Задача: Поиск индекса подстроки

* Пользователь вводит строку и подстроку.
* Найти индекс первого вхождения подстроки в строку.
* Вывести индекс или сообщение, если подстрока не найдена.

Задача: Проверка на палиндром

* Пользователь вводит строку.
* Проверить, является ли введенная строка палиндромом (читается одинаково слева направо и справа налево).
* Вывести сообщение о результате проверки.

Задача: Проверка на уникальность

* Пользователь вводит строку.
* Проверить, явлются ли символы в ней уникальными.
* Вывести сообщение о результате проверки.
"""