# -*- coding: utf-8 -*-
"""innoDom_lesson_15.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1oVXa1jvHMrX2cSHi5kerrgK7nRtlNzo9

# **Принципы ООП. Классификация методов класса, генераторы и итераторы, модификаторы доступов**

**Классификация методов класса:**

Методы в ООП можно поделить на следующие фракции:

1. Магические методы
2. Динамические методы
3. Статические методы
4. Классовые методы
5. Абстрактные методы
"""

class Demo:
    counter = 0

    def __init__(self, name) -> None:
        self.name = name

    def dynamic_method(self):
        pass



"""**Магические методы:**

`Магические методы` - также известные как специальные методы в языке Python представляют собой специальные функции, которые позволяют определить поведение объектов класса при выполнении определенных операций. Они начинаются и заканчиваются двойным подчеркиванием: (`__init__`, `__str__`, `__len__`...)

* `__init__(self):` используется для инициализации объекта класса и установки его атрибутов(если есть)
* `__str__(self):` возвращает строковое представление объекта класса, которое будет использовано при вызове функции str()
* `__repr__(self):` определяет строковое представление объекта  при вызове функции repr().
"""

class SomeExamples:
    counter = 0

    def __init__(self, name) -> None:
        self.name = name

    def dynamic_method(self):
        pass

    def __str__(self) -> str:
        return f"Hello from '__str__' method! {self.name}"

    def __repr__(self) -> str:
        return f"""
        =================
        person name: {self.name}
        counter: {self.counter}
        =================
        """

some_ex = SomeExamples("Olya")

repr(some_ex)

str(some_ex)

"""* `__getitem__(self):` может быть полезным при работе с различными коллекциями данных, например, для получения информации о торговых параметрах или балансах пользователей.
* `__setitem__(self):`Если в разработке используется возможность обновления или изменения данных, то метод `__setitem__` может быть полезным для установки значений параметров или обновления состояния объектов.
* `__del__(self):` В контексте блокчейн системы или мониторинга, метод `__del__` может быть использован для выполнения очистки ресурсов или закрытия подключений при удалении объектов или завершении работы.
* `__eq__(self):` В контексте торговли криптовалютой или блокчейн системы, метод `__eq__` может использоваться для сравнения объектов, таких как транзакции или блоки, на равенство или идентичность.
* `__len__(self):` Если API или система поддерживает коллекции данных, такие как список транзакций или список ордеров, метод `__len__` позволяет получить количество элементов в коллекции.
"""

class MyList:
    def __init__(self, items, x, y) -> None:
        self.items = items
        self.x = x
        self.y = y

    def __getitem__(self, index):
        return self.items[index]

    def __setitem__(self, index, value):
        self.items[index] = value

    def __eq__(self, other_obj) -> bool:
        return self.x == other_obj.x or self.y == other_obj.y

my_list = MyList([9, 8, 7, 6, 5, 4, 3, 2, 1])
[9, 8, 7, 6, 5, 4, 3, 2, 1][3]

eq = MyList([1], 5, 2)
eq2 = MyList([1], 1, 2)

print(eq == eq2)

print(my_list[3])

my_list[3] = 70
print(my_list.items)

class Person:
    def __init__(self, name) -> None:
        self.name = name

    def __del__(self):
        print(f"Person {self.name} was deleted.")


alice = Person("Alice")

del alice

"""Дополнительных магических методов достаточно много есть, но далеко не факт, что вы можете с ними столкнуться при работе \ своей конкретной разработке (пэтпроджекте).

С остальными маг методами можно ознакомиться [здесь](https://rszalski.github.io/magicmethods/)

**Статические методы в классах:**

По статике в наших классах у нас есть атрибуты и методы.
Со статическими атрибутами есть ещё вот какая интересная особенность:
"""

class Test:
    x = 1

t1 = Test()

print(f"Via instance: {t1.x}")
print(f"Via class: {Test.x}")

t1.x = 2

print(f"Via instance: {t1.x}")
print(f"Via class: {Test.x}")

Test.x = 3

print(f"Via instance: {t1.x}")
print(f"Via class: {Test.x}")

"""`Статический метод` - метод, который привязан к классу, а не к экземпляру класса. Он не требует создания объекта класса для вызова и может использоваться как внутри класса, так и без его создания.

Их можно воспринимать как методы, которые “не знают, к какому классу относятся”.

Таким образом, статические методы прикреплены к классу лишь для удобства и не могут менять состояние ни класса, ни его экземпляра.

Cтатические методы не могут получить доступ к параметрам класса или объекта. Они работают только с теми данными, которые им передаются в качестве аргументов. Но при этом мы можем вызывать через объект класса. Вызов через точку нужен лишь для удобства.


`ключевые особенности статических методов`:

1. Они объявляются с использованием декоратора `@staticmethod` перед определением метода внутри класса.
2. Они не принимают ссылку на экземпляр класса (обычно называемую `self`), как это делают обычные методы.
3. Они не имеют доступа к атрибутам или методам экземпляра класса, потому что они не связаны с конкретным объектом.
4. Они могут использоваться для группировки связанных функций, которые логически относятся к классу, но не требуют доступа к его состоянию.
"""

from uuid import uuid4


class Patient:
    def __init__(self, name, age, id_number) -> None:
        self.id = self.generate_uniq_id()
        self.name = name
        self.age = age
        self.id_number = id_number
        self.is_adult = self.check_age(self.age)


    @staticmethod
    def generate_uniq_id():
        return str(uuid4())[:8]


    @staticmethod
    def check_age(age):
        return age > 18


    @staticmethod
    def check_id_number(id_number):
        return len(str(id_number)) == 8


    def __repr__(self):
        return f"""
        ============================
        Patient's name: {self.name}
        Patient's age: {self.age}
        Patient's unique ID {self.id}
        Patient's ID number {self.id_number}
        Patient's adult - {self.is_adult}
        ID validate - {self.check_id_number(self.id_number)}
        ============================
        """

alex_patient = Patient("Alex", 27, 45675)

alex_patient

"""Статические методы в основном используются как вспомогательные функции и работают с данными, которые им передаются.

Статические методы работают как обычные функции, но принадлежат области имён класса. Они не имеют доступа ни к самому классу, ни к его экземплярам

**Классовые методы в классах:**

Python позволяет в классе иметь только один метод `__init__():`. Иногда это может быть проблемой.

Главной проблемой здесь является то, что иногда наши классы могут быть созданы через объект (инстанциированы) по-разному.

Может быть n способов полностью валидного создания объекта класса и попытка создания некоего "универсального" метода `__init__():` с кучей параметров, многие из которых будут иметь значение по умолчанию - такая себе идея.

Такие методы становятся слишком перегруженными, не особо понятными, плохо читабельными и сложными в понимании.

Помимо этого инициализатор `__init__():` не имеет конкретного имени: когда нам нужно инициализировать наш класс через конструктор, мы просто прописываем имя класса и дальше передаём нужные аргументы в скобках.

Иногда такого синтаксиса (к сожалению) недостаточно, чтобы писать "выразительный", понятный код.

В таких случаях нам могут помочь классовые методы


`Классовые методы` являются особой разновидностью методов в классах Python. Они привязаны к классу в целом, а не к его экземплярам.


Методы работы с классовыми методами:

1. Фабричные методы: (использование классовых методов как конструкторов класса)

Классовые методы могут использоваться для создания объектов класса с определенными параметрами или на основе определенной логики. Это особенно полезно, когда у класса есть различные способы создания экземпляров с разными конфигурациями
"""

class Sample:
    counter = 0

    def __init__(self) -> None:
        self.dynamic_counter = 0


    @classmethod
    def increment_counter(cls):
        cls.counter += 1

sample = Sample()



"""2. Методы альтернативного конструктора:

Классовые методы могут использоваться для создания объектов класса с помощью альтернативных способов, отличных от использования конструктора __init__. Это полезно, когда у нас есть специальные требования или сложная логика для инициализации объекта.

Такой подход позволяет создавать объекты с помощью альтернативных способов инициализации, не ограничиваясь только конструктором __init__. Классовый метод предоставляет удобный способ создания объектов с использованием другой логики и параметров.

Классовые методы предоставляют удобный способ организации логики, связанной с классом в целом, и предоставляют гибкость при создании объектов или выполнении операций, не привязанных к конкретным экземплярам класса.

Они могут использоваться для фабричных методов, альтернативных конструкторов, управления состоянием класса и других задач, где требуется доступ к классу, но не к его экземплярам.
"""



import sqlite3


class DatabaseConnection:
    instance = None
    db_connection = None

    @classmethod
    def get_instance(cls):
        if not cls.instance:
            cls.instance = cls()
        return cls.instance


    @classmethod
    def create_db_connection(cls):
        if not cls.db_connection:
            cls.db_connection = sqlite3.connect(":memory:")
        return cls.instance

    @classmethod
    def close_db_conn(cls):
        cls.db_connection.close()

t1 = DatabaseConnection.get_instance()
t2 = DatabaseConnection.get_instance()

print(t1)
print(t2)
print(t1 is t2)

"""**Синглтоны:**

`singleton (синглтон)` - это паттерн проектирования, который ограничивает создание только одного экземпляра определенного класса и предоставляет глобальную точку доступа к этому экземпляру.


При первом вызове классового метода создается новый экземпляр и сохраняется в атрибуте класса. При последующих вызовах классового метода возвращается сохраненный экземпляр.

При написании синглтонов реализация метода `__init__(self)` не прокатит, так как он срабатывает уже после того, как у нас создаётся наш объект, и инициализирует наши атрибуты. В случае синглтонов подойдёт метод `__new__(cls)`
"""

class Singleton:
    instance = None

    def __new__(cls):
        if Singleton.instance is None:
            Singleton.instance = super().__new__(cls)
            Singleton._connect_to_database(Singleton.instance)
        return Singleton.instance


    def _connect_to_database(self):
        print("Do some hard work")
        self.data = 101


    @classmethod
    def close_conn(cls):
        if cls.instance is None:
            raise Exception("Нет подключения")
        cls.instance._connect_to_database(cls.instance).close()

r3 = Singleton()
d4 = Singleton()

print(r2)
print(d2)

"""Один из примеров использования синглтонов - работа с подключением к Базе данных:"""



"""**Плюсы и минусы:**

1. Плюсы:

* Какие-то тяжёлые, долгие, ресурсоёмкие процессы будут выполняться всего один раз
* Синглтон имеет одну точку подключения для всей области работы.

2. Минусы:

* Общесистемная глобальная переменная
"""



"""В какой-то момент некий Алекс Мартел заметил, шо нам то собсна и не нужно, чтобы объект был всегда один и тот же. Главное - чтобы точка входа сама была одна. Из этого что, собственно вышло:"""



"""**Абстрактные методы:**

Понятие абстрактного метода вытекает из понятия абстрактного класса.
Если в классе существует хоть 1 абстрактный метод, то такой класс
называется абстрактным.

`Абстрактный метод` – это метод, который определяет своё существование
не вдаваясь в подробности реализации. Иными словами – это
нереализованный метод.


Абстрактные методы применяются в ситуациях, когда есть необходимость определить общий интерфейс для классов-наследников, но не предоставлять конкретную реализацию. Они часто используются для создания абстрактных базовых классов, которые описывают общее поведение, оставляя детали реализации для конкретных подклассов.

**Плюсы и минусы:**

* Плюсы:
1. Абстрактные методы позволяют определить общий интерфейс для классов-наследников, что способствует созданию чистой и понятной архитектуры кода.
2. Они помогают избежать некорректного использования классов-наследников, так как подклассы должны реализовать все абстрактные методы.
3. Абстрактные методы способствуют повышению переиспользуемости кода, так как позволяют определить общую функциональность для разных классов-наследников.

* Минусы:
1. Использование абстрактных методов может увеличить сложность кода, особенно при работе с большим количеством классов-наследников, требующих реализации различных абстрактных методов.
2. Неверная или неполная реализация абстрактных методов может привести к ошибкам во время выполнения программы.
"""

from abc import abstractclassmethod


class Vehicle:  #  транспорт

    @abstractclassmethod
    def get_all_vehicles(self):
        pass

    @abstractclassmethod
    def get_vehicle_by_id(self):
        pass

    @abstractclassmethod
    def calculate_vehicle_by_year(self):
        pass

import json

class Car(Vehicle):

    with open("cars.json", "r") as cars:
        data = json.load(cars)


    def get_all_vehicles(self):
        return self.data

    def get_vehicle_by_id(self, id):
        self.data = self.get_all_vehicles()
        filtered_by_id = filter(lambda x: x.get("id") == id, self.data)

        return filtered_by_id

    def calculate_vehicle_by_year(self):
        # some logic
        ...
        ...

"""**Итераторы и генераторы в классах:**

Итераторы и генераторы в Python используются для обхода и работы с последовательностями данных. Итераторы представляют собой объекты, которые реализуют методы `__iter__()` и `__next__()`, позволяющие последовательно возвращать элементы из коллекции. Генераторы являются специальным типом итераторов, создаваемых с использованием ключевого слова `yield`. Они позволяют удобно генерировать последовательности данных без необходимости создания полного списка заранее.

**Плюсы и минусы:**

* Плюсы:

1. Итераторы и генераторы позволяют эффективно работать с большими объемами данных, так как они загружают или вычисляют элементы по мере необходимости.
2. Они экономят память, так как не требуют создания полного списка элементов заранее.
3. Итераторы и генераторы упрощают итерацию и обход последовательностей данных, что делает код более компактным и понятным.

* Минусы:

1. Итераторы и генераторы не поддерживают прямой доступ к элементам по индексу. Их основное предназначение - последовательное получение элементов.
2. При использовании генераторов необходимо быть внимательным с сохранением состояния, так как каждый вызов генератора начинает выполнение с момента, где оно было остановлено.
"""

class SimpleIterator:
    def __iter__(self) -> None:
        return self

    def __init__(self, limit) -> None:
        self.limit = limit
        self.counter = 0

    def __next__(self):
        if self.counter < self.limit:
            self.counter += 1
            return self.counter
        else:
            raise StopIteration

simp_iter = SimpleIterator(5)

next(simp_iter)

next(simp_iter)

"""**Модификаторы доступа:**

Модификаторы доступа в Python используются для определения уровня доступности атрибутов и методов внутри класса. Они указывают, какие части кода могут получать доступ к определенным атрибутам или методам класса. В Python есть три типа модификаторов доступа: `public`, `protected` и `private`.

Модификаторы доступа применяются в классах для контроля доступа к их членам. Они помогают управлять видимостью и использованием атрибутов и методов класса извне класса и его подклассов.

`Public:` Атрибуты и методы, к которым можно получить доступ из любого места, не имеют специального префикса и являются публичными.

`Protected:` Атрибуты и методы, которые должны быть доступны только внутри класса и его подклассов, имеют префикс _ (одиночное подчеркивание).

`Private:` Атрибуты и методы, которые должны быть доступны только внутри самого класса, имеют префикс __ (двойное подчеркивание).

**Плюсы и минусы:**


* Плюсы:

1. Модификаторы доступа обеспечивают инкапсуляцию и скрывают детали реализации класса, предоставляя только необходимый интерфейс для работы с ним.
2. Они способствуют безопасности и предотвращают нежелательное изменение или доступ к внутренним данным класса.
3. Модификаторы доступа способствуют поддержке и развитию кодовой базы, так как они определяют контракт и интерфейс класса.

* Минусы:

1. Слишком строгое использование модификаторов доступа может усложнить расширение и изменение класса, особенно в больших проектах.
2. В Python нет жестких ограничений на модификаторы доступа, поэтому они являются скорее соглашениями и не могут быть полностью принудительными.
"""

class AvailableModificators:
    def __init__(self):
        self.public_var = 5
        self._private_var = 10
        self.__protected_var = 30

    def say_hello(self):
        print(self._private_var)

a1 = AvailableModificators()

print(a1._AvailableModificators__protected_var)

a1._private_var